OBJECT Codeunit 50020 Symmetric Encryption Mgt
{
  OBJECT-PROPERTIES
  {
    Date=20190215D;
    Time=161812.983T;
    Modified=true;
    Version List=;
  }
  PROPERTIES
  {
    OnRun=BEGIN

            // Helper Interface ======================================================================================
          END;

  }
  CODE
  {
    VAR
      KeySize@1000000001 : Integer;
      BlockSize@1000000000 : Integer;
      SymmetricAlgorithm@1000000003 : Text;
      Mode@1000000002 : ',CBC,ECB,OFB,CFB,CTS';
      Padding@1000000005 : ',None,PKCS7,Zeros,ANSIX923,ISO10126';
      DotNet_ArrayKey@1000000008 : Codeunit DotNet_Array;
      DotNet_ArrayIV@1000000007 : Codeunit DotNet_Array;
      E_NO_CIPHER@1000000004 : TextConst 'ENU=SymmetricAlgorithm - cipher not defined';
      E_INVALID_CIPHERMODE@1000000006 : TextConst 'ENU=Invalid Cipher mode';
      E_INVALID_PADDINGMODE@1000000009 : TextConst 'ENU=Invalid Padding mode';

    [External]
    [LineStart(319)]
    PROCEDURE SetCipher@1000000015(VAR CipherText@1000000000 : Text);
    VAR
      TempBlob@1000000001 : Record TempBlob;
    BEGIN

      // NOTE: Passing a cipher as plain text is not secure.
      // For a more secure interface use the SetCipherFromBlob interface

      if CipherText = '' then
        exit;

      TempBlob.WriteAsText(CipherText, TEXTENCODING::UTF8);
      if TrySetCipher(TempBlob) then ;
    END;

    [External]
    [LineStart(330)]
    PROCEDURE SetCipherFromBlob@1000000014(VAR TempBlob@1000000000 : Record TempBlob);
    BEGIN

      if TrySetCipher(TempBlob) then ;
    END;

    [External]
    [LineStart(334)]
    PROCEDURE Base64ToPlainText@1000000053(Base64Text@1000000000 : Text) : Text;
    VAR
      DotNet_Encoding@1000000001 : Codeunit DotNet_Encoding;
      DotNet_Convert@1000000002 : Codeunit DotNet_Convert;
      DotNetConvert@1000000004 : DotNet "'mscorlib'.System.Convert";
      DotNetEncoding@1000000003 : DotNet "'mscorlib'.System.Text.Encoding";
    BEGIN

      if Base64Text = '' then
        exit('');

      DotNet_Encoding.UTF8;
      DotNet_Encoding.GetEncoding(DotNetEncoding);
      DotNet_Convert.GetConvert(DotNetConvert);
      exit(DotNetEncoding.GetString(DotNetConvert.FromBase64String(Base64Text)));

      // Public Interface ======================================================================================
    END;

    [External]
    [LineStart(346)]
    PROCEDURE SetAlgorithm@1000000023(Algorithm@1000000000 : Text);
    BEGIN

      SymmetricAlgorithm := Algorithm;
    END;

    [External]
    [LineStart(350)]
    PROCEDURE SetKeySize@1000000021(Size@1000000000 : Integer);
    BEGIN

      KeySize := Size;
    END;

    [External]
    [LineStart(354)]
    PROCEDURE SetBlockSize@1000000022(Size@1000000000 : Integer);
    BEGIN

      BlockSize := Size;
    END;

    [External]
    [LineStart(358)]
    PROCEDURE SetMode@1000000024(CipherMode@1000000000 : Integer);
    VAR
      DotNet_CipherMode@1000000001 : Codeunit DotNet_CipherMode;
    BEGIN

      if (CipherMode < DotNet_CipherMode.CBC) or (CipherMode > DotNet_CipherMode.CTS) then
        Error(E_INVALID_CIPHERMODE);
      Mode := CipherMode;
    END;

    [External]
    [LineStart(364)]
    PROCEDURE SetPadding@1000000000(PaddingMode@1000000000 : Integer);
    VAR
      DotNet_PaddingMode@1000000001 : Codeunit DotNet_PaddingMode;
    BEGIN

      if (PaddingMode < DotNet_PaddingMode.None) or (PaddingMode > DotNet_PaddingMode.ISO10126) then
        Error(E_INVALID_PADDINGMODE);
      Padding := PaddingMode;
    END;

    [External]
    [LineStart(370)]
    PROCEDURE SetKey@1000000008(VAR DotNet_Array@1000000000 : Codeunit DotNet_Array);
    BEGIN

      DotNet_Array.Clone(DotNet_ArrayKey);
    END;

    [External]
    [LineStart(374)]
    PROCEDURE SetIV@1000000009(VAR DotNet_Array@1000000000 : Codeunit DotNet_Array);
    BEGIN

      DotNet_Array.Clone(DotNet_ArrayIV);
    END;

    [External]
    [LineStart(378)]
    PROCEDURE EncryptTextBase64@1000000001(UnEncryptedText@1000000000 : Text;VAR EncryptedTextBase64@1000000003 : Text) : Boolean;
    VAR
      Result@1000000002 : Boolean;
    BEGIN

      if StrLen(UnEncryptedText) > 0 then
        Result := TryEncryptTextBase64(UnEncryptedText, EncryptedTextBase64);
      ClearLastError;
      exit(Result);
    END;

    [External]
    [LineStart(385)]
    PROCEDURE DecryptTextBase64@1000000002(EncryptedText@1000000000 : Text;VAR UnEncryptedText@1000000003 : Text) : Boolean;
    VAR
      Result@1000000002 : Boolean;
    BEGIN

      if StrLen(EncryptedText) > 0 then
        Result := TryDecryptTextBase64(EncryptedText, UnEncryptedText);
      ClearLastError;
      exit(Result);
    END;

    [External]
    [LineStart(392)]
    PROCEDURE EncryptTempBlob@1000000006(VAR UnEncryptedTempBlob@1000000000 : Record TempBlob;VAR EncryptedTempBlob@1000000003 : Record TempBlob) : Boolean;
    VAR
      Result@1000000002 : Boolean;
    BEGIN

      Result := TryEncryptTempBlob(UnEncryptedTempBlob, EncryptedTempBlob);
      ClearLastError;
      exit(Result);
    END;

    [External]
    [LineStart(398)]
    PROCEDURE DecryptTempBlob@1000000005(VAR EncryptedTempBlob@1000000000 : Record TempBlob;VAR DecryptedTempBlob@1000000003 : Record TempBlob) : Boolean;
    VAR
      Result@1000000002 : Boolean;
    BEGIN

      Result := TryDecryptTempBlob(EncryptedTempBlob, DecryptedTempBlob);
      ClearLastError;
      exit(Result);
    END;

    [External]
    [LineStart(404)]
    PROCEDURE EncryptStream@1000000003(VAR UnEncryptedStream@1000000002 : InStream;VAR EncryptedStream@1000000000 : OutStream) : Boolean;
    VAR
      Result@1000000003 : Boolean;
    BEGIN

      Result := TryEncryptStream(UnEncryptedStream, EncryptedStream);
      ClearLastError;
      exit(Result);
    END;

    [External]
    [LineStart(410)]
    PROCEDURE DecryptStream@1000000004(VAR EncryptedStream@1000000001 : InStream;VAR UnEncryptedStream@1000000000 : OutStream) : Boolean;
    VAR
      Result@1000000003 : Boolean;
    BEGIN

      Result := TryDecryptStream(EncryptedStream, UnEncryptedStream);
      ClearLastError;
      exit(Result);

      // Private Interface ======================================================================================
    END;

    [LineStart(418)]
    LOCAL PROCEDURE KeyLengthInBytes@1000000017() : Integer;
    VAR
      Size@1000000000 : Integer;
    BEGIN

      if KeySize = 0 then
        KeySize := 256;
      exit(KeySize/8);
    END;

    [TryFunction]
    [LineStart(424)]
    LOCAL PROCEDURE TryEncryptTextBase64@1000000040(VAR UnEncryptedText@1000000012 : Text;VAR EncryptedTextBase64@1000000014 : Text);
    VAR
      OStream@1000000002 : OutStream;
      TempBlobUnEncrypted@1000000001 : Record TempBlob;
      TempBlobEncrypted@1000000000 : Record TempBlob;
    BEGIN

      // Push unencrypted text into tempblob
      Clear(TempBlobUnEncrypted.Blob);
      if UnEncryptedText <> '' then begin
        TempBlobUnEncrypted.Blob.CreateOutStream(OStream);
        OStream.WriteText(UnEncryptedText);
      end;

      // Encrypt
      if TryEncryptTempBlob(TempBlobUnEncrypted, TempBlobEncrypted) then
      begin
        // Read the encrypted text from the encrypted tempblob
        EncryptedTextBase64 := TempBlobEncrypted.ToBase64String();
      end else begin
        ClearLastError;
        Error('Encrypt failed');
      end;
    END;

    [TryFunction]
    [LineStart(443)]
    LOCAL PROCEDURE TryDecryptTextBase64@1000000039(VAR EncryptedTextBase64@1000000001 : Text;VAR DecryptedText@1000000000 : Text);
    VAR
      IStream@1000000008 : InStream;
      TempBlobDecrypted@1000000006 : Record TempBlob;
      TempBlobEncrypted@1000000005 : Record TempBlob;
      DotNet_Encoding@1000000003 : Codeunit DotNet_Encoding;
      DotNet_MemoryStream@1000000004 : Codeunit DotNet_MemoryStream;
      DotNetEncoding@1000000002 : DotNet "'mscorlib'.System.Text.Encoding";
      DotNetMemoryStream@1000000007 : DotNet "'mscorlib'.System.IO.MemoryStream";
    BEGIN

      // Anything to do?
      if EncryptedTextBase64 = '' then
        exit;

      // Push converted base64 encrypted text into blob
      TempBlobEncrypted.FromBase64String(EncryptedTextBase64);

      // Decrypt
      if TryDecryptTempBlob(TempBlobEncrypted, TempBlobDecrypted) and TempBlobDecrypted.Blob.HasValue then
      begin
        // Create a stream to read from decrypted blob
        TempBlobDecrypted.Blob.CreateInStream(IStream);

        // Read the decrypted bytes from the blob
        DotNet_MemoryStream.InitMemoryStream();
        DotNet_MemoryStream.CopyFromInStream(IStream);
        DotNet_MemoryStream.GetMemoryStream(DotNetMemoryStream);

        // Convert to text using UTF8 encoding
        DotNet_Encoding.UTF8;
        DotNet_Encoding.GetEncoding(DotNetEncoding);
        DecryptedText := DotNetEncoding.GetString(DotNetMemoryStream.ToArray());

      end else begin
        ClearLastError;
        Error('Decrypt failed');
      end;
    END;

    [TryFunction]
    [LineStart(473)]
    LOCAL PROCEDURE TryEncryptTempBlob@1000000012(VAR UnEncryptedTempBlob@1000000006 : Record TempBlob;VAR EncryptedTempBlob@1000000002 : Record TempBlob);
    VAR
      IStream@1000000001 : InStream;
      OStream@1000000000 : OutStream;
    BEGIN

      // Create a stream to read from unencrypted tempblob
      UnEncryptedTempBlob.Blob.CreateInStream(IStream);

      // Create a stream to write to encrypted tempblob
      EncryptedTempBlob.Init();
      EncryptedTempBlob.Blob.CreateOutStream(OStream);

      // Encrypt
      if not TryEncryptStream(IStream, OStream) then
      begin
        ClearLastError;
        Error('Encrypt failed');
      end;
    END;

    [TryFunction]
    [LineStart(489)]
    LOCAL PROCEDURE TryDecryptTempBlob@1000000007(VAR EncryptedTempBlob@1000000001 : Record TempBlob;VAR DecryptedTempBlob@1000000000 : Record TempBlob);
    VAR
      IStream@1000000008 : InStream;
      OStream@1000000007 : OutStream;
    BEGIN

      // Create a stream to read from encrypted tempblob
      EncryptedTempBlob.Blob.CreateInStream(IStream);

      // Create a stream to write to decrypted tempblob
      Clear(DecryptedTempBlob.Blob);
      DecryptedTempBlob.Blob.CreateOutStream(OStream);

      // Decrypt
      if not TryDecryptStream(IStream, OStream) then
      begin
        ClearLastError;
        Error('Decrypt failed');
      end;
    END;

    [TryFunction]
    [LineStart(505)]
    LOCAL PROCEDURE TryEncryptStream@1000000035(VAR UnEncryptedStream@1000000001 : InStream;VAR EncryptedStream@1000000000 : OutStream);
    VAR
      DotNetSymmetricAlgorithm@1000000021 : DotNet "'mscorlib'.System.Security.Cryptography.SymmetricAlgorithm";
      DotNetICryptoTransform@1000000020 : DotNet "'mscorlib'.System.Security.Cryptography.ICryptoTransform";
      DotNetCryptoStream@1000000019 : DotNet "'mscorlib'.System.Security.Cryptography.CryptoStream";
      DotNetCryptoStreamMode@1000000018 : DotNet "'mscorlib'.System.Security.Cryptography.CryptoStreamMode";
      DotNetEncoding@1000000017 : DotNet "'mscorlib'.System.Text.Encoding";
      DotNetStreamReader@1000000016 : DotNet "'mscorlib'.System.IO.StreamReader";
      DotNetStreamWriter@1000000015 : DotNet "'mscorlib'.System.IO.StreamWriter";
      DotNetArray@1000000013 : DotNet "'mscorlib'.System.Array";
      DotNet_SymmetricAlgorithm@1000000012 : Codeunit DotNet_SymmetricAlgorithm;
      DotNet_ICryptoTransform@1000000011 : Codeunit DotNet_ICryptoTransform;
      DotNet_CryptoStream@1000000010 : Codeunit DotNet_CryptoStream;
      DotNet_Encoding@1000000009 : Codeunit DotNet_Encoding;
      DotNet_StreamReader@1000000008 : Codeunit DotNet_StreamReader;
      DotNet_StreamWriter@1000000007 : Codeunit DotNet_StreamWriter;
      DotNet_StreamEncrypted@1000000005 : Codeunit DotNet_Stream;
      DotNet_StreamDecrypted@1000000004 : Codeunit DotNet_Stream;
      DotNet_Array@1000000002 : Codeunit DotNet_Array;
      BytesRead@1000000003 : Integer;
    BEGIN

      if TryCreateSymmetricAlgorithm(DotNet_SymmetricAlgorithm) then begin

        // encoding used for transforms
        DotNet_Encoding.UTF8;

        // setup reader for unencrypted stream
        DotNet_StreamReader.StreamReader(UnEncryptedStream, DotNet_Encoding);
        DotNet_StreamReader.GetStreamReader(DotNetStreamReader);

        // setup the encryption pipeline
        DotNet_SymmetricAlgorithm.GetSymmetricAlgorithm(DotNetSymmetricAlgorithm);
        DotNetICryptoTransform := DotNetSymmetricAlgorithm.CreateEncryptor();
        DotNet_ICryptoTransform.SetICryptoTransform(DotNetICryptoTransform);
        DotNet_CryptoStream.CryptoOutStream(EncryptedStream, DotNet_ICryptoTransform);
        DotNet_CryptoStream.GetCryptoStream(DotNetCryptoStream);

        // setup crypto writer for encrypted stream
        DotNet_StreamEncrypted.SetStream(DotNetCryptoStream);
        DotNet_StreamWriter.StreamWriterFromDotNetStream(DotNet_StreamEncrypted, DotNet_Encoding);
        DotNet_StreamWriter.GetStreamWriter(DotNetStreamWriter);

        // create a byte array buffer for data transfer
        DotNet_Array.ByteArray(4096);
        DotNet_Array.GetArray(DotNetArray);

        // encrypt
        repeat
          BytesRead := DotNetStreamReader.BaseStream.Read(DotNetArray, 0, DotNetArray.Length);
          if BytesRead > 0 then
            DotNetStreamWriter.BaseStream.Write(DotNetArray, 0, BytesRead);
        until BytesRead < 1;
        DotNetStreamWriter.Flush();

        // dispose
        DotNetStreamReader.Dispose();
        DotNetStreamWriter.Dispose();
        DotNetCryptoStream.Dispose();
        DotNetICryptoTransform.Dispose();
        DotNetSymmetricAlgorithm.Dispose();
      end;
    END;

    [TryFunction]
    [LineStart(548)]
    LOCAL PROCEDURE TryDecryptStream@1000000036(VAR EncryptedStream@1000000001 : InStream;VAR DecryptedStream@1000000000 : OutStream);
    VAR
      DotNetSymmetricAlgorithm@1000000010 : DotNet "'mscorlib'.System.Security.Cryptography.SymmetricAlgorithm";
      DotNetICryptoTransform@1000000016 : DotNet "'mscorlib'.System.Security.Cryptography.ICryptoTransform";
      DotNetCryptoStream@1000000008 : DotNet "'mscorlib'.System.Security.Cryptography.CryptoStream";
      DotNetCryptoStreamMode@1000000007 : DotNet "'mscorlib'.System.Security.Cryptography.CryptoStreamMode";
      DotNetEncoding@1000000020 : DotNet "'mscorlib'.System.Text.Encoding";
      DotNetStreamReader@1000000005 : DotNet "'mscorlib'.System.IO.StreamReader";
      DotNetStreamWriter@1000000004 : DotNet "'mscorlib'.System.IO.StreamWriter";
      DotNetArray@1000000006 : DotNet "'mscorlib'.System.Array";
      DotNet_SymmetricAlgorithm@1000000002 : Codeunit DotNet_SymmetricAlgorithm;
      DotNet_ICryptoTransform@1000000009 : Codeunit DotNet_ICryptoTransform;
      DotNet_CryptoStream@1000000011 : Codeunit DotNet_CryptoStream;
      DotNet_Encoding@1000000012 : Codeunit DotNet_Encoding;
      DotNet_StreamReader@1000000013 : Codeunit DotNet_StreamReader;
      DotNet_StreamWriter@1000000014 : Codeunit DotNet_StreamWriter;
      DotNet_StreamEncrypted@1000000017 : Codeunit DotNet_Stream;
      DotNet_StreamDecrypted@1000000018 : Codeunit DotNet_Stream;
      DotNet_Array@1000000015 : Codeunit DotNet_Array;
      BytesRead@1000000003 : Integer;
    BEGIN

      if TryCreateSymmetricAlgorithm(DotNet_SymmetricAlgorithm) then begin

        // encoding used for transforms
        DotNet_Encoding.UTF8;

        // setup the decryption pipeline
        DotNet_SymmetricAlgorithm.GetSymmetricAlgorithm(DotNetSymmetricAlgorithm);
        DotNetICryptoTransform := DotNetSymmetricAlgorithm.CreateDecryptor();
        DotNet_ICryptoTransform.SetICryptoTransform(DotNetICryptoTransform);
        DotNet_CryptoStream.CryptoInStream(EncryptedStream, DotNet_ICryptoTransform);
        DotNet_CryptoStream.GetCryptoStream(DotNetCryptoStream);

        // setup reader for encrypted stream
        DotNet_StreamEncrypted.SetStream(DotNetCryptoStream);
        DotNet_StreamReader.StreamReaderFromDotNetStream(DotNet_StreamEncrypted, DotNet_Encoding);
        DotNet_StreamReader.GetStreamReader(DotNetStreamReader);

        // setup writer for decrypted stream
        DotNet_StreamWriter.StreamWriter(DecryptedStream, DotNet_Encoding);
        DotNet_StreamWriter.GetStreamWriter(DotNetStreamWriter);

        // create a byte array buffer for data transfer
        DotNet_Array.ByteArray(4096);
        DotNet_Array.GetArray(DotNetArray);

        // decrypt
        repeat
          BytesRead := DotNetStreamReader.BaseStream.Read(DotNetArray, 0, DotNetArray.Length);
          if BytesRead > 0 then
            DotNetStreamWriter.BaseStream.Write(DotNetArray, 0, BytesRead);
        until BytesRead < 1;
        DotNetStreamWriter.Flush();
        DotNetStreamWriter.Close();

        // dispose
        DotNetStreamReader.Dispose();
        DotNetStreamWriter.Dispose();
        DotNetCryptoStream.Dispose();
        DotNetICryptoTransform.Dispose();
        DotNetSymmetricAlgorithm.Dispose();
      end;
    END;

    [TryFunction]
    [LineStart(592)]
    LOCAL PROCEDURE TryCreateSymmetricAlgorithm@1000000025(VAR DotNet_SymmetricAlgorithm@1000000005 : Codeunit DotNet_SymmetricAlgorithm);
    BEGIN

      if (DotNet_ArrayIV.Length = 0) or (DotNet_ArrayIV.Length = 0) then
        Error(E_NO_CIPHER);

      DotNet_SymmetricAlgorithm.Create(SymmetricAlgorithm);
      if Mode > 0 then DotNet_SymmetricAlgorithm.SetMode(Mode);
      if BlockSize > 0 then DotNet_SymmetricAlgorithm.SetBlockSize(BlockSize);
      if Padding > 0 then DotNet_SymmetricAlgorithm.SetPadding(Padding);
      if KeySize > 0 then DotNet_SymmetricAlgorithm.SetKeySize(KeySize);
      DotNet_SymmetricAlgorithm.SetKey(DotNet_ArrayKey);
      DotNet_SymmetricAlgorithm.SetIV(DotNet_ArrayIV);
    END;

    [TryFunction]
    [LineStart(605)]
    LOCAL PROCEDURE TrySetCipher@1000000016(VAR TempBlob@1000000000 : Record TempBlob);
    VAR
      IStream@1000000001 : InStream;
      DotNet_HashAlgorithm@1000000006 : Codeunit DotNet_HashAlgorithm;
      DotNet_ArrayHashBytes@1000000012 : Codeunit DotNet_Array;
    BEGIN

      // Generate a Key & IV from the cipher text stored in the blob
      // This method uses a SHA384 hash of the cipher to generate the
      // bytes for the Key & IV

      TempBlob.Blob.CreateInStream(IStream);

      DotNet_HashAlgorithm.Create('SHA384');
      DotNet_HashAlgorithm.ComputeHashFromInStream(IStream, DotNet_ArrayHashBytes);

      DotNet_ArrayKey.ByteArray(KeyLengthInBytes);
      DotNet_ArrayHashBytes.ConstrainedCopy(0, DotNet_ArrayKey, 0, KeyLengthInBytes);

      DotNet_ArrayIV.ByteArray(16);
      DotNet_ArrayHashBytes.ConstrainedCopy(KeyLengthInBytes, DotNet_ArrayIV, 0, 16);

      DotNet_HashAlgorithm.Dispose();
    END;

    BEGIN
    END.
  }
}

