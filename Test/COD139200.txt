OBJECT Codeunit 139200 XML Buffer Tests
{
  OBJECT-PROPERTIES
  {
    Date=;
    Time=;
    Version List=Test,ERM,W1,All;
  }
  PROPERTIES
  {
    Subtype=Test;
    TestPermissions=NonRestrictive;
    OnRun=BEGIN
            // [FEATURE] [XML Buffer]
          END;

  }
  CODE
  {
    VAR
      LibraryUtility@1000 : Codeunit 131000;
      Assert@1005 : Codeunit 130000;
      FileManagement@1006 : Codeunit 419;
      LibraryRandom@10000000 : Codeunit 130440;

    [Test]
    PROCEDURE CreateTempRootNodeWithoutNamespace@9();
    VAR
      TempXMLBuffer@1000 : TEMPORARY Record 1235;
    BEGIN
      // [GIVEN] A temporary XML Buffer
      // [WHEN] Creating a root element with no namespace
      // [THEN] Only this one root element is added
      // [THEN] Node has correct values
      CreateAndVerifyRootNode(TempXMLBuffer,0,FALSE);
    END;

    [Test]
    PROCEDURE CreateTempRootNodeWithNamespace@10();
    VAR
      TempXMLBuffer@1000 : TEMPORARY Record 1235;
    BEGIN
      // [GIVEN] A temporary XML Buffer
      // [WHEN] Creating a root element with one namespace
      // [THEN] A root element is added
      // [THEN] A namespace attribute is added
      // [THEN] Node and namespace has correct values
      CreateAndVerifyRootNode(TempXMLBuffer,1,FALSE);
    END;

    [Test]
    PROCEDURE CreateTempRootNodeWithMultipleNamespaces@11();
    VAR
      TempXMLBuffer@1002 : TEMPORARY Record 1235;
    BEGIN
      // [GIVEN] A temporary XML Buffer
      // [WHEN] Creating a root element with two namespaces
      // [THEN] A root element is added
      // [THEN] Two namespace attributes are added
      // [THEN] Node and namespaces have correct values
      CreateAndVerifyRootNode(TempXMLBuffer,2,FALSE);
    END;

    [Test]
    PROCEDURE CreateTempRootNodeWithDefaultNamespace@12();
    VAR
      TempXMLBuffer@1002 : TEMPORARY Record 1235;
    BEGIN
      // [GIVEN] A temporary XML Buffer
      // [WHEN] Creating a root element with a default namespace (no prefix)
      // [THEN] A root element is added
      // [THEN] One namespace attributes is added
      // [THEN] Node and namespace has correct values
      CreateAndVerifyRootNode(TempXMLBuffer,1,TRUE);
    END;

    [Test]
    PROCEDURE SaveAndLoadTempRootNodeWithoutNamespace@13();
    BEGIN
      // [GIVEN] A temporary XML Buffer
      // [GIVEN] A root element with no namespace
      // [WHEN] Saving and then loading the XML Buffer
      // [THEN] The two XML Buffer lists are identical
      CreateSaveLoadAndVerifyTempXmlBuffer(0,FALSE);
    END;

    [Test]
    PROCEDURE SaveAndLoadTempRootNodeWithNamespace@14();
    BEGIN
      // [GIVEN] A temporary XML Buffer
      // [GIVEN] A root element with one namespace
      // [WHEN] Saving and then loading the XML Buffer
      // [THEN] The two XML Buffer lists are identical
      CreateSaveLoadAndVerifyTempXmlBuffer(1,FALSE);
    END;

    [Test]
    PROCEDURE SaveAndLoadTempRootNodeWithMultipleNamespaces@15();
    BEGIN
      // [GIVEN] A temporary XML Buffer
      // [GIVEN] A root element with two namespaces
      // [WHEN] Saving and then loading the XML Buffer
      // [THEN] The two XML Buffer lists are identical
      CreateSaveLoadAndVerifyTempXmlBuffer(2,FALSE);
    END;

    [Test]
    PROCEDURE SaveAndLoadTempRootNodeWithDefaultNamespace@16();
    BEGIN
      // [GIVEN] A temporary XML Buffer
      // [GIVEN] A root element with default namespace
      // [WHEN] Saving and then loading the XML Buffer
      // [THEN] The two XML Buffer lists are identical
      CreateSaveLoadAndVerifyTempXmlBuffer(1,TRUE);
    END;

    [Test]
    PROCEDURE SaveAndLoadTempElementsWithoutNamespace@70();
    BEGIN
      // [GIVEN] A temporary XML Buffer
      // [GIVEN] A root element and subelements with no namespace
      // [WHEN] Saving and then loading the XML Buffer
      // [THEN] The two XML Buffer lists are identical
      CreateSaveLoadAndVerifyTempXmlBufferWithNodes(0,FALSE);
    END;

    [Test]
    PROCEDURE SaveAndLoadTempElementsWithNamespace@69();
    BEGIN
      // [GIVEN] A temporary XML Buffer
      // [GIVEN] A root element and subelements with one namespace
      // [WHEN] Saving and then loading the XML Buffer
      // [THEN] The two XML Buffer lists are identical
      CreateSaveLoadAndVerifyTempXmlBufferWithNodes(1,FALSE);
    END;

    [Test]
    PROCEDURE SaveAndLoadTempElementsWithMultipleNamespaces@68();
    BEGIN
      // [GIVEN] A temporary XML Buffer
      // [GIVEN] A root element and subelements with two namespaces
      // [WHEN] Saving and then loading the XML Buffer
      // [THEN] The two XML Buffer lists are identical
      CreateSaveLoadAndVerifyTempXmlBufferWithNodes(2,FALSE);
    END;

    [Test]
    PROCEDURE SaveAndLoadTempElementsWithDefaultNamespace@67();
    BEGIN
      // [GIVEN] A temporary XML Buffer
      // [GIVEN] A root element and subelements with default namespace
      // [WHEN] Saving and then loading the XML Buffer
      // [THEN] The two XML Buffer lists are identical
      CreateSaveLoadAndVerifyTempXmlBufferWithNodes(1,TRUE);
    END;

    [Test]
    PROCEDURE TempElementsWithSpecialCharacters@87();
    VAR
      TempXMLBuffer@1001 : TEMPORARY Record 1235;
      TempChildXMLBuffer@1004 : TEMPORARY Record 1235;
      RootNodeName@1000 : Text[250];
      ElementName@1005 : Text[250];
      ElementValue@1006 : Text[250];
      NamespacePrefix@1003 : ARRAY [2] OF Text[250];
      NamespacePath@1002 : ARRAY [2] OF Text[250];
    BEGIN
      // [GIVEN] An XML Buffer root element
      CreateRootNode(TempXMLBuffer,2,FALSE,RootNodeName,NamespacePrefix,NamespacePath);
      // [WHEN] Adding an XML element with special characters
      ElementName := 'A-._������';
      ElementValue := '�!"#�%&/()=?`�@�${[]}|+/*-,.-;:_<>\�������^''';
      TempXMLBuffer.AddElement(ElementName,ElementValue);

      // [THEN] The XML Buffer root node has one child with the same name and value
      Assert.IsTrue(TempXMLBuffer.HasChildNodes,'root element should have children.');
      Assert.AreEqual(1,TempXMLBuffer.CountChildElements,'Incorrect number of child nodes');
      Assert.IsTrue(TempXMLBuffer.FindChildElements(TempChildXMLBuffer),'root element should have children.');
      Assert.AreEqual(ElementName,TempChildXMLBuffer.Name,'Child name mismatch.');
      Assert.AreEqual(ElementValue,TempChildXMLBuffer.GetValue,'Child value mismatch.');
    END;

    [Test]
    PROCEDURE TempElementProcessingInstructionsWithSpecialCharacters@10000000();
    VAR
      TempXMLBuffer@1001 : TEMPORARY Record 1235;
      TempChildXMLBuffer@1004 : TEMPORARY Record 1235;
      RootNodeName@1000 : Text[250];
      ElementName@1005 : Text[250];
      ElementValue@1006 : Text[250];
      NamespacePrefix@1003 : ARRAY [2] OF Text[250];
      NamespacePath@1002 : ARRAY [2] OF Text[250];
      PIInstructionName@10000001 : Text;
      PIInstructionValue@10000000 : Text;
    BEGIN
      // [GIVEN] An XML Buffer root element
      CreateRootNode(TempXMLBuffer,2,FALSE,RootNodeName,NamespacePrefix,NamespacePath);

      // [GIVEN] Adding an XML element with special characters
      ElementName := 'A-._������';
      ElementValue := '�!"#�%&/()=?`��@�${[]}|+/*-,.-;:_<>\�������^''';
      TempXMLBuffer.AddElement(ElementName,ElementValue);

      // [WHEN] Adding an XML Processing instructions with special characters
      PIInstructionName := 'A-._������';
      PIInstructionValue := '�!"#�%&/()=?`��@�${[]}|+/*-,.-;:_<>\�������^''';
      TempXMLBuffer.AddProcessingInstruction(PIInstructionName, PIInstructionValue);

      // [THEN] The XML Buffer root node has one processing instruction with the same name and value
      Assert.AreEqual(1,TempXMLBuffer.CountProcessingInstructions,'Incorrect number of child processing instructions');
      Assert.IsTrue(TempXMLBuffer.FindProcessingInstructions(TempChildXMLBuffer),'element should have processing instructions.');
      Assert.AreEqual(PIInstructionName,TempChildXMLBuffer.Name,'Processing Instruction name mismatch.');
      Assert.AreEqual(PIInstructionValue,TempChildXMLBuffer.GetValue,'Processing Instruction value mismatch.');
    END;

    [Test]
    PROCEDURE CreateValueWithLengthOver250Characters@37();
    VAR
      TempXMLBuffer@1001 : TEMPORARY Record 1235;
      TempChildXMLBuffer@1004 : TEMPORARY Record 1235;
      LibraryRandom@1007 : Codeunit 130440;
      RootNodeName@1000 : Text[250];
      ElementName@1005 : Text[250];
      ElementValue@1006 : Text;
      NamespacePrefix@1003 : ARRAY [2] OF Text[250];
      NamespacePath@1002 : ARRAY [2] OF Text[250];
    BEGIN
      // [GIVEN] An XML Buffer root element
      CreateRootNode(TempXMLBuffer,2,FALSE,RootNodeName,NamespacePrefix,NamespacePath);
      // [WHEN] Adding an XML element with value longer than 250 characters
      ElementName := COPYSTR(LibraryUtility.GenerateRandomAlphabeticText(10,0),1,250);
      ElementValue := LibraryRandom.RandText(300);
      TempXMLBuffer.AddElement(ElementName,ElementValue);

      // [THEN] The XML Buffer root node has one child with the same name and value
      Assert.IsTrue(TempXMLBuffer.HasChildNodes,'root element should have children.');
      Assert.AreEqual(1,TempXMLBuffer.CountChildElements,'Incorrect number of child nodes');
      Assert.IsTrue(TempXMLBuffer.FindChildElements(TempChildXMLBuffer),'root element should have children.');
      Assert.AreEqual(ElementName,TempChildXMLBuffer.Name,'Child name mismatch.');
      Assert.AreEqual(ElementValue,TempChildXMLBuffer.GetValue,'Child value mismatch.');
    END;

    [Test]
    PROCEDURE CreateElementProcessingInstructionValueWithLengthOver250Characters@10000003();
    VAR
      TempXMLBuffer@1001 : TEMPORARY Record 1235;
      TempChildXMLBuffer@1004 : TEMPORARY Record 1235;
      LibraryRandom@1007 : Codeunit 130440;
      RootNodeName@1000 : Text[250];
      ElementName@1005 : Text[250];
      ElementValue@1006 : Text;
      NamespacePrefix@1003 : ARRAY [2] OF Text[250];
      NamespacePath@1002 : ARRAY [2] OF Text[250];
      PIInstructionName@10000000 : Text;
      PIInstructionValue@10000001 : Text;
    BEGIN
      // [GIVEN] An XML Buffer root element
      CreateRootNode(TempXMLBuffer,2,FALSE,RootNodeName,NamespacePrefix,NamespacePath);

      // [WHEN] Adding an XML element
      ElementName := COPYSTR(LibraryUtility.GenerateRandomAlphabeticText(10,0),1,250);
      ElementValue := LibraryRandom.RandText(300);
      TempXMLBuffer.AddElement(ElementName,ElementValue);

      // [WHEN] Adding an XML element processing instruction longer than 250 characters
      PIInstructionName := COPYSTR(LibraryUtility.GenerateRandomAlphabeticText(10,0),1,250);
      PIInstructionValue := LibraryRandom.RandText(300);
      TempXMLBuffer.AddProcessingInstruction(PIInstructionName,PIInstructionValue);

      // [THEN] The XML Buffer root node has one processing instruction with the same name and value
      Assert.AreEqual(1,TempXMLBuffer.CountProcessingInstructions,'Incorrect number of child processing instructions');
      Assert.IsTrue(TempXMLBuffer.FindProcessingInstructions(TempChildXMLBuffer),'element should have processing instructions.');
      Assert.AreEqual(PIInstructionName,TempChildXMLBuffer.Name,'Processing Instruction name mismatch.');
      Assert.AreEqual(PIInstructionValue,TempChildXMLBuffer.GetValue,'Processing Instruction value mismatch.');
    END;

    [Test]
    PROCEDURE SaveAndLoadTempElementsWithSpecialCharacters@89();
    VAR
      TempXMLBuffer@1001 : TEMPORARY Record 1235;
      RootNodeName@1000 : Text[250];
      NamespacePrefix@1003 : ARRAY [2] OF Text[250];
      NamespacePath@1002 : ARRAY [2] OF Text[250];
    BEGIN
      // [GIVEN] An XML Buffer root element
      // [GIVEN] A subelement containing special characters
      CreateRootNode(TempXMLBuffer,2,FALSE,RootNodeName,NamespacePrefix,NamespacePath);
      TempXMLBuffer.AddAttribute('_','�!#�%/()=?`�@�${[]}|+/*�-,.-;:_\�^''');
      TempXMLBuffer.AddElement('A-._','�!"#�%&/()=?`��@�${[]}|+/*-,.-;:_<>\�^''');

      // [WHEN] Saving and then loading the XML Buffer
      // [THEN] The two XML Buffer lists are identical
      SaveLoadAndVerifyTempXmlBuffer(TempXMLBuffer);
    END;

    [Test]
    PROCEDURE SaveAndLoadTempElementsAndProcessingInstructionsWithSpecialCharacters@10000005();
    VAR
      TempXMLBuffer@1001 : TEMPORARY Record 1235;
      RootNodeName@1000 : Text[250];
      NamespacePrefix@1003 : ARRAY [2] OF Text[250];
      NamespacePath@1002 : ARRAY [2] OF Text[250];
    BEGIN
      // [GIVEN] An XML Buffer root element
      // [GIVEN] A subelement containing special characters
      CreateRootNode(TempXMLBuffer,2,FALSE,RootNodeName,NamespacePrefix,NamespacePath);
      TempXMLBuffer.AddAttribute('_','�!#�%/()=?`�@�${[]}|+/*�-,.-;:_\�^''');
      TempXMLBuffer.AddElement('A-._','�!"#�%&/()=?`��@�${[]}|+/*-,.-;:_<>\�^''');
      TempXMLBuffer.AddProcessingInstruction('A-._������','�!"#�%&/()=?`��@�${[]}|+/*-,.-;:_<>\�������^''');

      // [WHEN] Saving and then loading the XML Buffer
      // [THEN] The two XML Buffer lists are identical
      SaveLoadAndVerifyTempXmlBuffer(TempXMLBuffer);
    END;

    [Test]
    PROCEDURE TempFindNodesByXPath@88();
    VAR
      TempXMLBuffer@1001 : TEMPORARY Record 1235;
      TempChildXMLBuffer@1004 : TEMPORARY Record 1235;
      RootNodeName@1000 : Text[250];
      ElementName@1005 : Text[250];
      ElementValue@1006 : Text[250];
      NamespacePrefix@1003 : ARRAY [2] OF Text[250];
      NamespacePath@1002 : ARRAY [2] OF Text[250];
    BEGIN
      // [GIVEN] A temporary XML Buffer structure containing three elements with the same name
      // [GIVEN] One of these elements contains an attribute
      CreateRootNode(TempXMLBuffer,2,FALSE,RootNodeName,NamespacePrefix,NamespacePath);
      ElementName := COPYSTR(LibraryUtility.GenerateRandomAlphabeticText(10,0),1,250);
      ElementValue := COPYSTR(LibraryUtility.GenerateRandomAlphabeticText(10,0),1,250);
      TempXMLBuffer.AddGroupElement(ElementName);
      TempXMLBuffer.AddAttribute(
        COPYSTR(LibraryUtility.GenerateRandomAlphabeticText(10,0),1,250),
        COPYSTR(LibraryUtility.GenerateRandomAlphabeticText(10,0),1,250));
      TempXMLBuffer.GetParent;
      TempXMLBuffer.AddElement(ElementName,ElementValue);
      TempXMLBuffer.AddElement(ElementName,ElementValue);
      // [WHEN] XMLBuffer.FindNodesByXPath is called with the name of these elements
      // [THEN] Only the three elements are found
      // [THEN] The entire subtree is not returned I.E. the attribute
      Assert.IsTrue(
        TempXMLBuffer.FindNodesByXPath(TempChildXMLBuffer,'/' + ElementName),
        'root element should have children.');

      Assert.AreEqual(ElementName,TempChildXMLBuffer.Name,'First child name is incorrect.');
      TempChildXMLBuffer.NEXT;
      Assert.AreEqual(ElementName,TempChildXMLBuffer.Name,'Second child name is incorrect.');
      Assert.AreEqual(ElementValue,TempChildXMLBuffer.GetValue,'Second child value is incorrect.');
      TempChildXMLBuffer.NEXT;
      Assert.AreEqual(ElementName,TempChildXMLBuffer.Name,'Third child name is incorrect.');
      Assert.AreEqual(ElementValue,TempChildXMLBuffer.GetValue,'Third child value is incorrect.');
      TempChildXMLBuffer.NEXT;
    END;

    [Test]
    PROCEDURE FindNodesByXPath@29();
    VAR
      XMLBuffer@1001 : Record 1235;
      TempChildXMLBuffer@1004 : TEMPORARY Record 1235;
      RootNodeName@1000 : Text[250];
      ElementName@1005 : Text[250];
      ElementValue@1006 : Text[250];
      NamespacePrefix@1003 : ARRAY [2] OF Text[250];
      NamespacePath@1002 : ARRAY [2] OF Text[250];
    BEGIN
      CreateRootNode(XMLBuffer,2,FALSE,RootNodeName,NamespacePrefix,NamespacePath);
      ElementName := COPYSTR(LibraryUtility.GenerateRandomAlphabeticText(10,0),1,250);
      ElementValue := COPYSTR(LibraryUtility.GenerateRandomAlphabeticText(10,0),1,250);
      XMLBuffer.AddGroupElement(ElementName);
      XMLBuffer.AddAttribute(
        COPYSTR(LibraryUtility.GenerateRandomAlphabeticText(10,0),1,250),
        COPYSTR(LibraryUtility.GenerateRandomAlphabeticText(10,0),1,250));
      XMLBuffer.GetParent;
      XMLBuffer.AddElement(ElementName,ElementValue);
      XMLBuffer.AddElement(ElementName,ElementValue);
      Assert.IsTrue(
        XMLBuffer.FindNodesByXPath(TempChildXMLBuffer,'/' + ElementName),
        'root element should have children.');

      Assert.AreEqual(ElementName,TempChildXMLBuffer.Name,'First child name is incorrect.');
      TempChildXMLBuffer.NEXT;
      Assert.AreEqual(ElementName,TempChildXMLBuffer.Name,'Second child name is incorrect.');
      Assert.AreEqual(ElementValue,TempChildXMLBuffer.GetValue,'Second child value is incorrect.');
      TempChildXMLBuffer.NEXT;
      Assert.AreEqual(ElementName,TempChildXMLBuffer.Name,'Third child name is incorrect.');
      Assert.AreEqual(ElementValue,TempChildXMLBuffer.GetValue,'Third child value is incorrect.');
      TempChildXMLBuffer.NEXT;
    END;

    [Test]
    PROCEDURE CreateRootNodeWithoutNamespace@22();
    VAR
      XMLBuffer@1000 : Record 1235;
    BEGIN
      // [GIVEN] A permanent XML Buffer
      // [WHEN] Creating a root element with no namespace
      // [THEN] Only this one root element is added
      // [THEN] Node has correct values
      CreateAndVerifyRootNode(XMLBuffer,0,FALSE);
    END;

    [Test]
    PROCEDURE CreateRootNodeWithNamespace@21();
    VAR
      XMLBuffer@1000 : Record 1235;
    BEGIN
      // [GIVEN] A permanent XML Buffer
      // [WHEN] Creating a root element with one namespace
      // [THEN] A root element is added
      // [THEN] A namespace attribute is added
      // [THEN] Node and namespace has correct values
      CreateAndVerifyRootNode(XMLBuffer,1,FALSE);
    END;

    [Test]
    PROCEDURE CreateRootNodeWithMultipleNamespaces@20();
    VAR
      XMLBuffer@1002 : Record 1235;
    BEGIN
      // [GIVEN] A permanent XML Buffer
      // [WHEN] Creating a root element with two namespaces
      // [THEN] A root element is added
      // [THEN] Two namespace attributes are added
      // [THEN] Node and namespaces have correct values
      CreateAndVerifyRootNode(XMLBuffer,2,FALSE);
    END;

    [Test]
    PROCEDURE CreateRootNodeWithDefaultNamespace@19();
    VAR
      XMLBuffer@1002 : Record 1235;
    BEGIN
      // [GIVEN] A permanent XML Buffer
      // [WHEN] Creating a root element with a default namespace (no prefix)
      // [THEN] A root element is added
      // [THEN] One namespace attributes is added
      // [THEN] Node and namespace has correct values
      CreateAndVerifyRootNode(XMLBuffer,1,TRUE);
    END;

    [Test]
    PROCEDURE SaveAndLoadRootNodeWithoutNamespace@18();
    BEGIN
      // [GIVEN] A permanent XML Buffer
      // [GIVEN] A root element with no namespace
      // [WHEN] Saving and then loading the XML Buffer
      // [THEN] The two XML Buffer lists are identical
      CreateSaveLoadAndVerifyXmlBuffer(0,FALSE);
    END;

    [Test]
    PROCEDURE SaveAndLoadRootNodeWithNamespace@17();
    BEGIN
      // [GIVEN] A permanent XML Buffer
      // [GIVEN] A root element with one namespace
      // [WHEN] Saving and then loading the XML Buffer
      // [THEN] The two XML Buffer lists are identical
      CreateSaveLoadAndVerifyXmlBuffer(1,FALSE);
    END;

    [Test]
    PROCEDURE SaveAndLoadRootNodeWithMultipleNamespaces@8();
    BEGIN
      // [GIVEN] A permanent XML Buffer
      // [GIVEN] A root element with two namespaces
      // [WHEN] Saving and then loading the XML Buffer
      // [THEN] The two XML Buffer lists are identical
      CreateSaveLoadAndVerifyXmlBuffer(2,FALSE);
    END;

    [Test]
    PROCEDURE SaveAndLoadRootNodeWithDefaultNamespace@7();
    BEGIN
      // [GIVEN] A permanent XML Buffer
      // [GIVEN] A root element with default namespace
      // [WHEN] Saving and then loading the XML Buffer
      // [THEN] The two XML Buffer lists are identical
      CreateSaveLoadAndVerifyXmlBuffer(1,TRUE);
    END;

    [Test]
    PROCEDURE SaveAndLoadNodesWithoutNamespace@6();
    BEGIN
      // [GIVEN] A permanent XML Buffer
      // [GIVEN] A root element and subelements with no namespace
      // [WHEN] Saving and then loading the XML Buffer
      // [THEN] The two XML Buffer lists are identical
      CreateSaveLoadAndVerifyXmlBufferWithNodes(0,FALSE);
    END;

    [Test]
    PROCEDURE SaveAndLoadNodesWithNamespace@5();
    BEGIN
      // [GIVEN] A permanent XML Buffer
      // [GIVEN] A root element and subelements with one namespace
      // [WHEN] Saving and then loading the XML Buffer
      // [THEN] The two XML Buffer lists are identical
      CreateSaveLoadAndVerifyXmlBufferWithNodes(1,FALSE);
    END;

    [Test]
    PROCEDURE SaveAndLoadNodesWithMultipleNamespaces@4();
    BEGIN
      // [GIVEN] A permanent XML Buffer
      // [GIVEN] A root element and subelements with two namespaces
      // [WHEN] Saving and then loading the XML Buffer
      // [THEN] The two XML Buffer lists are identical
      CreateSaveLoadAndVerifyXmlBufferWithNodes(2,FALSE);
    END;

    [Test]
    PROCEDURE SaveAndLoadNodesWithDefaultNamespace@3();
    BEGIN
      // [GIVEN] A permanent XML Buffer
      // [GIVEN] A root element and subelements with two namespaces
      // [WHEN] Saving and then loading the XML Buffer
      // [THEN] The two XML Buffer lists are identical
      CreateSaveLoadAndVerifyXmlBufferWithNodes(1,TRUE);
    END;

    [Test]
    PROCEDURE LoadAndSaveFile@2();
    VAR
      XMLBuffer@1001 : Record 1235;
      ServerFileName@1000 : Text;
      ResultServerFileName@1002 : Text;
    BEGIN
      // [GIVEN] An XML file
      ServerFileName := CreateXmlFile;
      // [WHEN] The XML file is loaded into NAV using permanent XML Buffer and saved again to disk
      XMLBuffer.Load(ServerFileName);
      ResultServerFileName := FileManagement.ServerTempFileName('.xml');
      XMLBuffer.Save(ResultServerFileName);
      // [THEN] The XML file loaded into NAV is identical to the XML file exported from NAV
      VerifyIdenticalFiles(ServerFileName,ResultServerFileName);
    END;

    [Test]
    PROCEDURE LoadAndSaveFileUsingTemporaryRecords@1();
    VAR
      TempXMLBuffer@1001 : TEMPORARY Record 1235;
      ServerFileName@1000 : Text;
      ResultServerFileName@1002 : Text;
    BEGIN
      // [GIVEN] An XML file
      ServerFileName := CreateXmlFile;
      // [WHEN] The XML file is loaded into NAV using permanent XML Buffer and saved again to disk
      TempXMLBuffer.Load(ServerFileName);
      ResultServerFileName := FileManagement.ServerTempFileName('.xml');
      TempXMLBuffer.Save(ResultServerFileName);
      // [THEN] The XML file loaded into NAV is identical to the XML file exported from NAV
      VerifyIdenticalFiles(ServerFileName,ResultServerFileName);
    END;

    [Test]
    PROCEDURE LoadFromInstream@30();
    VAR
      TempXMLBuffer@1002 : TEMPORARY Record 1235;
      File@1000 : File;
      InStream@1001 : InStream;
    BEGIN
      // [GIVEN] An input stream
      File.OPEN(CreateXmlFile,TEXTENCODING::UTF8);
      File.CREATEINSTREAM(InStream);

      // [WHEN] Loading the input stream
      TempXMLBuffer.Load(InStream);

      // [THEN] The XML Buffer table is not empty
      Assert.IsFalse(TempXMLBuffer.ISEMPTY,'Load from stream failed, the resulting XML Buffer is empty.');
    END;

    [Test]
    PROCEDURE LoadFromText@33();
    VAR
      XMLBuffer@1001 : Record 1235;
      XmlText@1000 : Text;
    BEGIN
      // [GIVEN] Xml text
      XmlText := '<?xml version="1.0" encoding="UTF-8"?>' +
        '<RootElement xmlns="namespaceURI">' +
        '  <SelfClosingElement attribute="attributeValue" />' +
        '</RootElement>';

      // [WHEN] Loading the xml text
      XMLBuffer.LoadFromText(XmlText);

      // [THEN] The xml text elements and attributes have been inserted into proper XML Buffer records
      Assert.AreEqual('RootElement',XMLBuffer.Name,'');
      Assert.AreEqual('namespaceURI',XMLBuffer.GetAttributeValue('xmlns'),'');
      Assert.AreEqual(1,XMLBuffer.CountChildElements,'There should be exactly one child element.');
    END;

    [Test]
    PROCEDURE CreateNonEmptyElements@34();
    VAR
      XMLBuffer@1000 : Record 1235;
      GroupNodeXMLBuffer@1001 : Record 1235;
      GroupNode2XMLBuffer@1002 : Record 1235;
    BEGIN
      // [GIVEN] An xml buffer has been created with add NonEmpty elements
      XMLBuffer.CreateRootElement('RootNode');
      XMLBuffer.AddElement('emptyElement','');
      XMLBuffer.AddNonEmptyElement('ignoredElement','');
      XMLBuffer.AddNonEmptyElement('nonEmptyElement','value');
      // [GIVEN] A group node has been added with a nonempty last node, with blank value
      XMLBuffer.AddGroupElement('groupNode');
      GroupNodeXMLBuffer := XMLBuffer;
      XMLBuffer.AddNonEmptyLastElement('ignoredElement','');
      // [GIVEN] A group node has been added with a nonempty last node, with a value
      XMLBuffer.AddGroupElement('groupNode2');
      GroupNode2XMLBuffer := XMLBuffer;
      XMLBuffer.AddNonEmptyLastElement('nonEmptyElement','value2');

      // [THEN] The root node contains four children
      Assert.AreEqual(4,XMLBuffer.CountChildElements,'Incorrect number of child elements of the root element.');
      // [THEN] The first group node does not contain any child nodes
      Assert.IsFalse(GroupNodeXMLBuffer.HasChildNodes,'The group node should not have any child elements.');
      // [THEN] The second group node has exactly one child element
      Assert.IsTrue(GroupNode2XMLBuffer.HasChildNodes,'The second group node should have children.');
      Assert.AreEqual(1,GroupNode2XMLBuffer.CountChildElements,'Incorrect number of child elements of the root element.');
    END;

    [Test]
    PROCEDURE InsertElementAtSpecificPosition@35();
    VAR
      TempXMLBuffer@1000 : TEMPORARY Record 1235;
      TempChildElementsXMLBuffer@1001 : TEMPORARY Record 1235;
      Element2Position@1002 : Integer;
      TempChildElementsPIXMLBuffer@10000000 : TEMPORARY Record 1235;
    BEGIN
      // [GIVEN] An XML Buffer with a root element and two child elements A and B
      TempXMLBuffer.CreateRootElement('RootNode');
      TempXMLBuffer.AddElement('Element1','value1');
      TempXMLBuffer.AddProcessingInstruction('PIName1', 'PIValue1');
      Element2Position := TempXMLBuffer.AddElement('Element2','value2');

      // [GIVEN] The XML buffer is sorted after "Parent Entry No.","Node Number"
      TempXMLBuffer.SETCURRENTKEY("Parent Entry No.",Type,"Node Number");

      // [WHEN] A group node C is added between child element 1 and 2
      TempXMLBuffer.AddGroupElementAt('newGroupBetweenElement1and2',Element2Position);
      TempXMLBuffer.GetParent;

      // [THEN] In order, the child elements of the root node are A, C, B
      Assert.IsTrue(TempXMLBuffer.FindChildElements(TempChildElementsXMLBuffer),'No child elements were found.');
      Assert.AreEqual('Element1',TempChildElementsXMLBuffer.Name,'');
      Assert.IsTrue(TempXMLBuffer.FindProcessingInstructions(TempChildElementsPIXMLBuffer),'No child elements processing instructions were found.');
      Assert.AreEqual('PIName1',TempChildElementsPIXMLBuffer.Name,'');
      TempChildElementsXMLBuffer.NEXT;
      Assert.AreEqual('newGroupBetweenElement1and2',TempChildElementsXMLBuffer.Name,'');
      TempChildElementsXMLBuffer.NEXT;
      Assert.AreEqual('Element2',TempChildElementsXMLBuffer.Name,'');
    END;

    [Test]
    PROCEDURE InsertElementAtSaveAndLoad@52();
    VAR
      TempXMLBuffer@1000 : TEMPORARY Record 1235;
    BEGIN
      // [GIVEN] An XML Buffer with a root element and two child elements A and B
      TempXMLBuffer.CreateRootElement('RootNode');
      TempXMLBuffer.AddElement('Element1','value1');
      TempXMLBuffer.AddProcessingInstruction('PIName1', 'PIValue1');
      TempXMLBuffer.AddElement('Element2','value2');

      // [GIVEN] A group node C is added between child element 1 and 2
      TempXMLBuffer.AddGroupElementAt('newGroupBetweenElement1and2',2);
      TempXMLBuffer.GetParent;

      // [WHEN] Saving and then loading the XML Buffer
      // [THEN] The two XML Buffer lists are identical
      SaveLoadAndVerifyXmlBuffer(TempXMLBuffer);
    END;

    [Test]
    PROCEDURE GetParentFunctionNotFailedWhenNoXMLBufferExists@36();
    VAR
      XMLBuffer@1000 : Record 1235;
    BEGIN
      // [FEATURE] [UT]
      // [SCENARIO 263386] When function GetParent of XML Buffer table invokes it is not fail if record does not exist

      XMLBuffer.DELETEALL;
      XMLBuffer."Parent Entry No." := 1;
      XMLBuffer.GetParent;
      XMLBuffer.TESTFIELD("Entry No.",0);
    END;

    LOCAL PROCEDURE CreateAndVerifyRootNode@31(VAR TempXMLBuffer@1000 : TEMPORARY Record 1235;NumNamespaces@1001 : Integer;DefaultNamespace@1002 : Boolean);
    VAR
      TempChildrenXMLBuffer@1003 : TEMPORARY Record 1235;
      TempIgnoredXMLBuffer@1005 : TEMPORARY Record 1235;
      RootNodeName@1004 : Text[250];
      NamespacePrefix@1007 : ARRAY [2] OF Text[250];
      NamespacePath@1006 : ARRAY [2] OF Text[250];
    BEGIN
      CreateRootNode(TempXMLBuffer,NumNamespaces,DefaultNamespace,RootNodeName,NamespacePrefix,NamespacePath);

      Assert.IsFalse(TempXMLBuffer.FindChildElements(TempIgnoredXMLBuffer),'root element should not have child elements.');
      IF NumNamespaces = 0 THEN
        Assert.IsFalse(TempXMLBuffer.HasChildNodes,'root element should not have children.')
      ELSE
        Assert.IsTrue(TempXMLBuffer.HasChildNodes,'root element should have children.');

      Assert.AreEqual(RootNodeName,TempXMLBuffer.Name,'root element name is wrong');
      Assert.AreEqual(0,TempXMLBuffer.CountChildElements,'root element has an incorrect number of child nodes');
      Assert.AreEqual(NumNamespaces,TempXMLBuffer.CountAttributes,'root element has incorrect number of attributes');

      IF NumNamespaces > 0 THEN BEGIN
        Assert.IsTrue(TempXMLBuffer.FindAttributes(TempChildrenXMLBuffer),'');
        IF DefaultNamespace THEN
          Assert.AreEqual(TempChildrenXMLBuffer.Name,'xmlns','')
        ELSE
          Assert.AreEqual(TempChildrenXMLBuffer.Name,'xmlns:' + NamespacePrefix[1],'');
        Assert.AreEqual(TempChildrenXMLBuffer.Value,NamespacePath[1],'');

        IF NumNamespaces = 2 THEN BEGIN
          TempChildrenXMLBuffer.NEXT;
          Assert.AreEqual('xmlns:' + NamespacePrefix[2],TempChildrenXMLBuffer.Name,'');
          Assert.AreEqual(NamespacePath[2],TempChildrenXMLBuffer.Value,'');
          Assert.AreEqual(NamespacePath[2],TempXMLBuffer.GetAttributeValue('xmlns:' + NamespacePrefix[2]),'');
        END;
      END;
    END;

    LOCAL PROCEDURE AddElements@72(VAR TempXMLBuffer@1000 : TEMPORARY Record 1235);
    VAR
      NamespacePrefix@1001 : Text;
      PICount@10000000 : Integer;
      i@10000001 : Integer;
    BEGIN
      NamespacePrefix := TempXMLBuffer.Namespace;
      IF NamespacePrefix <> '' THEN
        NamespacePrefix += ':';

      TempXMLBuffer.AddElement(NamespacePrefix + 'Element1','Value1');
      TempXMLBuffer.AddElement(
        COPYSTR(LibraryUtility.GenerateRandomAlphabeticText(MAXSTRLEN(TempXMLBuffer.Name),0),1,250),'');
      TempXMLBuffer.AddGroupElement(NamespacePrefix + 'Element2');
      TempXMLBuffer.AddAttribute('attribute1','attributeValue1');
      TempXMLBuffer.AddAttribute('EmptyAttribute','');

      PICount := LibraryRandom.RandInt(3);
      FOR i := 1 TO PICount DO
        TempXMLBuffer.AddProcessingInstruction('PIName' + FORMAT(i), 'PIValue' + FORMAT(i));

      TempXMLBuffer.AddElement(NamespacePrefix + 'Element3','Value3');
      TempXMLBuffer.AddLastElement(NamespacePrefix + 'Element4','Value4');
      TempXMLBuffer.AddGroupElement('emptyGroupnodeWithoutNamespace');
      TempXMLBuffer.GetParent;
      TempXMLBuffer.AddElement(NamespacePrefix + 'Element5','');
      TempXMLBuffer.AddElement('DuplicateElementName','Value6');
      TempXMLBuffer.AddElement('DuplicateElementName','Value7');
      TempXMLBuffer.AddElement('DuplicateElementName','Value8');
    END;

    LOCAL PROCEDURE CreateRootNode@32(VAR TempXMLBuffer@1002 : TEMPORARY Record 1235;NumNamespaces@1003 : Integer;DefaultNamespace@1001 : Boolean;VAR RootNodeName@1000 : Text[250];VAR NamespacePrefix@1004 : ARRAY [2] OF Text[250];VAR NamespacePath@1005 : ARRAY [2] OF Text[250]);
    BEGIN
      RootNodeName := COPYSTR(LibraryUtility.GenerateRandomAlphabeticText(10,0),1,250);
      TempXMLBuffer.CreateRootElement(RootNodeName);
      IF NumNamespaces > 0 THEN BEGIN
        NamespacePath[1] := COPYSTR(LibraryUtility.GenerateRandomAlphabeticText(50,0),1,250);
        IF NOT DefaultNamespace THEN
          NamespacePrefix[1] := COPYSTR(LibraryUtility.GenerateRandomAlphabeticText(1,0),1,250);
        TempXMLBuffer.AddNamespace(NamespacePrefix[1],NamespacePath[1]);

        IF NumNamespaces = 2 THEN BEGIN
          NamespacePath[2] := COPYSTR(LibraryUtility.GenerateRandomAlphabeticText(MAXSTRLEN(TempXMLBuffer.Value),0),1,250);
          NamespacePrefix[2] := COPYSTR(LibraryUtility.GenerateRandomAlphabeticText(MAXSTRLEN(TempXMLBuffer.Name) - 6,0),1,250); // STRLEN('XMLNS:') = 6
          TempXMLBuffer.AddNamespace(NamespacePrefix[2],NamespacePath[2]);
        END
      END;
    END;

    LOCAL PROCEDURE CreateSaveLoadAndVerifyTempXmlBuffer@24(NumNamespaces@1001 : Integer;DefaultNamespace@1000 : Boolean);
    VAR
      TempXMLBuffer@1003 : TEMPORARY Record 1235;
      RootNodeName@1002 : Text[250];
      NamespacePrefix@1005 : ARRAY [2] OF Text[250];
      NamespacePath@1004 : ARRAY [2] OF Text[250];
    BEGIN
      CreateRootNode(TempXMLBuffer,NumNamespaces,DefaultNamespace,RootNodeName,NamespacePrefix,NamespacePath);
      SaveLoadAndVerifyTempXmlBuffer(TempXMLBuffer);
    END;

    LOCAL PROCEDURE CreateSaveLoadAndVerifyTempXmlBufferWithNodes@25(NumNamespaces@1001 : Integer;DefaultNamespace@1000 : Boolean);
    VAR
      TempXMLBuffer@1003 : TEMPORARY Record 1235;
      RootNodeName@1002 : Text[250];
      NamespacePrefix@1005 : ARRAY [2] OF Text[250];
      NamespacePath@1004 : ARRAY [2] OF Text[250];
    BEGIN
      CreateRootNode(TempXMLBuffer,NumNamespaces,DefaultNamespace,RootNodeName,NamespacePrefix,NamespacePath);
      AddElements(TempXMLBuffer);
      SaveLoadAndVerifyTempXmlBuffer(TempXMLBuffer);
    END;

    LOCAL PROCEDURE CreateSaveLoadAndVerifyXmlBuffer@28(NumNamespaces@1001 : Integer;DefaultNamespace@1000 : Boolean);
    VAR
      XMLBuffer@1003 : Record 1235;
      RootNodeName@1002 : Text[250];
      NamespacePrefix@1005 : ARRAY [2] OF Text[250];
      NamespacePath@1004 : ARRAY [2] OF Text[250];
    BEGIN
      CreateRootNode(XMLBuffer,NumNamespaces,DefaultNamespace,RootNodeName,NamespacePrefix,NamespacePath);
      SaveLoadAndVerifyXmlBuffer(XMLBuffer);
    END;

    LOCAL PROCEDURE CreateSaveLoadAndVerifyXmlBufferWithNodes@27(NumNamespaces@1001 : Integer;DefaultNamespace@1000 : Boolean);
    VAR
      XMLBuffer@1003 : Record 1235;
      RootNodeName@1002 : Text[250];
      NamespacePrefix@1005 : ARRAY [2] OF Text[250];
      NamespacePath@1004 : ARRAY [2] OF Text[250];
    BEGIN
      CreateRootNode(XMLBuffer,NumNamespaces,DefaultNamespace,RootNodeName,NamespacePrefix,NamespacePath);
      AddElements(XMLBuffer);
      SaveLoadAndVerifyXmlBuffer(XMLBuffer);
    END;

    LOCAL PROCEDURE CreateXmlFile@23() ServerFileName : Text;
    VAR
      OutStream@1000 : OutStream;
      File@1001 : File;
    BEGIN
      ServerFileName := FileManagement.ServerTempFileName('.xml');
      File.CREATE(ServerFileName);
      File.TEXTMODE(TRUE);
      File.CREATEOUTSTREAM(OutStream);

      WriteLineToOutstream(OutStream,'<?xml version="1.0" encoding="UTF-8"?>');
      WriteLineToOutstream(OutStream,'<RootElement xmlns="namespaceURI">');
      WriteLineToOutstream(OutStream,'  <SelfClosingElement attribute="attributeValue" />');
      WriteLineToOutstream(OutStream,'  <Element1>');
      WriteLineToOutstream(OutStream,'    <Element11 attribute="" Attribute2="test">');
      WriteLineToOutstream(OutStream,'      <?PIName11 PIValue="PIValue11"?>');
      WriteLineToOutstream(OutStream,'      <Element111 attribute="" Attribute2="test" />');
      WriteLineToOutstream(OutStream,'      <Element112>Value</Element112>');
      WriteLineToOutstream(OutStream,'    </Element11>');
      WriteLineToOutstream(OutStream,'  </Element1>');
      WriteLineToOutstream(OutStream,'  <Element2>');
      WriteLineToOutstream(OutStream,'    <Element21 Currency="DK">1253.53</Element21>');
      WriteLineToOutstream(OutStream,'    <Element21 Currency="EUR">092,5310</Element21>');
      WriteLineToOutstream(OutStream,'  </Element2>');
      WriteLineToOutstream(OutStream,'</RootElement>');
      File.CLOSE;
    END;

    LOCAL PROCEDURE SaveLoadAndVerifyTempXmlBuffer@53(VAR TempXMLBuffer@1000 : TEMPORARY Record 1235);
    VAR
      TempXMLBufferLoaded@1001 : TEMPORARY Record 1235;
      ServerFilePath@1002 : Text;
    BEGIN
      ServerFilePath := FileManagement.ServerTempFileName('.xml');
      TempXMLBuffer.Save(ServerFilePath);
      TempXMLBufferLoaded.Load(ServerFilePath);
      VerifyIdenticalStructures(TempXMLBuffer,TempXMLBufferLoaded);
    END;

    LOCAL PROCEDURE SaveLoadAndVerifyXmlBuffer@26(VAR XMLBuffer@1000 : Record 1235);
    VAR
      XMLBufferLoaded@1001 : Record 1235;
      ServerFilePath@1002 : Text;
    BEGIN
      ServerFilePath := FileManagement.ServerTempFileName('.xml');
      XMLBuffer.Save(ServerFilePath);
      XMLBuffer.SETCURRENTKEY("Parent Entry No.",Type,"Node Number");
      XMLBufferLoaded.Load(ServerFilePath);
      XMLBufferLoaded.SETCURRENTKEY("Parent Entry No.",Type,"Node Number");
      VerifyIdenticalStructures(XMLBuffer,XMLBufferLoaded);
    END;

    LOCAL PROCEDURE VerifyIdenticalFiles@55(ExpectedFileName@1000 : Text;ActualFileName@1001 : Text);
    VAR
      ExpectedFile@1002 : File;
      ActualFile@1003 : File;
      ExpectedInStream@1004 : InStream;
      ActualInstream@1005 : InStream;
      ExpectedLine@1006 : Text;
      ActualLine@1007 : Text;
    BEGIN
      ExpectedFile.OPEN(ExpectedFileName,TEXTENCODING::UTF8);
      ExpectedFile.TEXTMODE(TRUE);
      ExpectedFile.CREATEINSTREAM(ExpectedInStream);
      ActualFile.OPEN(ActualFileName,TEXTENCODING::UTF8);
      ActualFile.TEXTMODE(TRUE);
      ActualFile.CREATEINSTREAM(ActualInstream);

      WHILE NOT (ExpectedInStream.EOS AND ActualInstream.EOS) DO BEGIN
        ExpectedInStream.READTEXT(ExpectedLine);
        ActualInstream.READTEXT(ActualLine);
        Assert.AreEqual(ExpectedLine,ActualLine,'Loaded and saved XML files are not identical.');
      END;
    END;

    LOCAL PROCEDURE VerifyIdenticalStructures@47(VAR ExpectedTempXMLBuffer@1000 : TEMPORARY Record 1235;VAR ActualTempXMLBuffer@1001 : TEMPORARY Record 1235);
    BEGIN
      // Since nodes are be imported in the same order as they are exported, we can just loop through each node:
      ExpectedTempXMLBuffer.SETRANGE("Import ID",ExpectedTempXMLBuffer."Import ID");
      ExpectedTempXMLBuffer.FINDSET;
      ActualTempXMLBuffer.SETRANGE("Import ID",ActualTempXMLBuffer."Import ID");
      ActualTempXMLBuffer.FINDSET;
      REPEAT
        Assert.AreEqual(ExpectedTempXMLBuffer.Type,ActualTempXMLBuffer.Type,'Type');
        Assert.AreEqual(ExpectedTempXMLBuffer.Name,ActualTempXMLBuffer.Name,'Name');
        Assert.AreEqual(ExpectedTempXMLBuffer.Path,ActualTempXMLBuffer.Path,'Path');
        Assert.AreEqual(ExpectedTempXMLBuffer.Value,ActualTempXMLBuffer.Value,'Value');
        Assert.AreEqual(ExpectedTempXMLBuffer.Depth,ActualTempXMLBuffer.Depth,'Depth');
        Assert.AreEqual(
          ExpectedTempXMLBuffer."Node Number",ActualTempXMLBuffer."Node Number",'Node Number ' + ActualTempXMLBuffer.Name);
        Assert.AreEqual(ExpectedTempXMLBuffer.Namespace,ActualTempXMLBuffer.Namespace,'Namespace');
      UNTIL (ExpectedTempXMLBuffer.NEXT = 0) OR (ActualTempXMLBuffer.NEXT = 0);
    END;

    LOCAL PROCEDURE WriteLineToOutstream@48(VAR OutStream@1001 : OutStream;Line@1000 : Text);
    BEGIN
      OutStream.WRITETEXT(Line);
      OutStream.WRITETEXT;
    END;

    BEGIN
    END.
  }
}

